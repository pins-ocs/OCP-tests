
# 
#            
# Zermelo Boat problem
# 
# 1 controllo
# Inizializzazione
restart:
with(XOptima):
# Equazioni del modello matematico del veicolo
EQ1  := diff(x(zeta),zeta) = T(zeta)*(V*cos(theta(zeta)) + velX(x(zeta),y(zeta))) :
EQ2  := diff(y(zeta),zeta) = T(zeta)*(V*sin(theta(zeta)) + velY(x(zeta),y(zeta))) :
EQ3  := diff(T(zeta),zeta) = 0:
EQNS := convert([EQ||(1..3)],Vector) ;
# Variabili del problema
# Variabili
xvars := [x(zeta),y(zeta),T(zeta)] ;
# Controlli
uvars := [theta(zeta)] ;
# BVP
addUserFunction(velX(x,y)=y/sqrt(x^2+y^2+epsilon^2)) ;
addUserFunction(velY(x,y)=-x/sqrt(x^2+y^2+epsilon^2)) ;
addUserFunction(arctan2(y,x),0) ;
loadDynamicSystem(equations=EQNS,controls=uvars,states=xvars) ;
addBoundaryConditions(initial=[x=x0,y=y0],final=[x=0,y=0]);
infoBoundaryConditions() ;
setTarget( mayer = T(zeta_f), lagrange = 0) ;
addUnilateralConstraint( T(zeta)>=0, Tpositive, tolerance=0.1 ) ;
Describe(setFDorder) ;
#setFDorder([3],"backward") ;
#setFDorderCoEquation([theta],"forward") ;
# Control deduced minimizing Hamiltonian
CONTROL := [theta = arctan2(-lambda2__xo(zeta),-lambda1__xo(zeta))] ;
GUESS := [ x=x0*(1-zeta), y=y0*(1-zeta), T=sqrt(x0^2+y0^2)/V, lambda2__xo = 0 ] ;
generateOCProblem( "ZermeloSimple",#language="MATLAB",clean=false,
                    integral_post_processing = [[zeta*T(zeta),"Time"]],
                    parameters     = [ V=5, x0=1, y0=0,epsilon=0.001],
                    #continuation  = [[epsi_u=1-s]],
                    mesh           = [ length=1, n=100 ],
                    controls_user_defined = CONTROL,
                    #controls_guess = [ theta = arctan2(-lambda2__xo(zeta),-lambda1__xo(zeta)) ],
                    states_guess   = GUESS ) ;
# Riscrivo il controllo con arctan2 e cambio g_vec
#u_vec[1] := arctan2(numer(tan(u_vec[1])),denom(tan(u_vec[1]))) ;
#g_vec[1] := u_vars[1] - u_vec[1] ;
#OCP := getOCProblem(verbose=true) ;

