# 
#            
# Modello Massa
# 
# 1 controllo
# (Problema tempo fisso, massima distanza)
# Inizializzazione
restart:
with(XOptima):
# Equazioni del modello matematico del veicolo
EQ1 := diff(x(t),t) - v(t);
EQ2 := diff(v(t),t) - clip(sT(t)-sB(t),minClip,maxClip);
EQ3 := diff(sT(t),t) + (sT(t) - vsT(t))/tauT ;
EQ4 := diff(sB(t),t) + (sB(t) - vsB(t))/tauB ;
EQNS_T := [ EQ||(1..4) ];
# Variabili del problema e controlli
# Variabili
qvars := [x(t),v(t),sT(t),sB(t)] ;
# Controlli
cvars := [vsT(t),vsB(t)] ;
# Equazioni del modello matematico del carrello
loadDynamicSystem(equations=EQNS_T,controls=cvars,states=qvars) ;
mapUserFunctionToRegularized( clip, "ClipIntervalWithErf" ) ;
# Inserisce condizioni al contorno
addBoundaryConditions(initial=[x=0,v=0,sT=0,sB=0],final=[v=0]);
infoBoundaryConditions() ;
# Inserisce le condizioni di salto 
# Penalty
addUnilateralConstraint( vsT(zeta) >= 0, vsTpositive );
addUnilateralConstraint( vsB(zeta) >= 0, vsBpositive );
addUnilateralConstraint( vsT(zeta) <= maxT, vsTmax );
addBilateralConstraint( vsT(zeta)-vsB(zeta), vsTBInterval );
setTarget(mayer=-x(zeta_f),lagrange = epsiTB*(vsT(zeta)^2+vsB(zeta)^2)) ;
# Target function
generateOCProblem( "BangBangFtau",
                   post_processing = [[sT(zeta)-sB(zeta),"F"],
                                      [clip(sT(zeta)-sB(zeta),minClip,maxClip),"clipF"]],
                   parameters = [epsiTB=0.001,
                                 tauT=0.02,
                                 tauB=0.001,
                                 maxT=2,
                                 #clip_h=0.1,
                                 #clip_delta=0.1,
                                 minClip=-1,
                                 maxClip=1],
                   controls_iterative = true,
                   controls_guess = [vsT=0,vsB=0],                   mesh = [[length=0.1,n=10],[length=0.4,n=40],[length=0.4,n=40],[length=0.1,n=10]] ) ;

